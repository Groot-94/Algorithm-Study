## 01. 선택 정렬(Selection Sort)
### 요약
- 선택정렬은 앞에서부터 차례대로 정렬하는 방법
- 제자리 정렬 알고리즘의 하나로, 다음과 같은 순서로 이루어진다.
  1. 주어진 리스트 중에 최소값을 찾는다.
  2.  그 값을 맨 앞에 위치한 값과 교체하거나 pass한다.
  3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
> 제자리 정렬은 원소들의 수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미
### 시각화

<img src="https://velog.velcdn.com/images/aiden/post/6fb41888-8053-4f9a-950c-369675418cc9/%EC%84%A0%ED%83%9D%20%EC%A0%95%EB%A0%AC.gif">

### 특징
- 장점
  - 간단한 구현
  - n개 원소에 대해 n개의 메모리를 사용하기에 데이터를 하나씩 정밀 비교가 가능하며 정렬을 위한 비교 횟수는 많으나 교환 횟수는 상당히 적다
    - 교환이 많이 이루어져야하는 자료 상태에서 가장 효율적
    - 내림차순으로 정렬되어 있는 자료를 오름차순으로 재정렬할 때 최적의 효율
- 단점
  - 비효율(높은 시간복잡도)
    - a to z를 돌면서 최소값을 찾기때문에 데이터의 크기가 커질수록 효율이 떨어진다.
    - 이미 정렬된 상태에서 소수의 자료가 추가됨으로 재정렬하게 되는 때에는 최악의 처리 속도를 보여준다
    - 데이터의 정렬 속도가 O(n^2)로 고정적으로 걸리기때문에 퀵, 삽입 정렬 등에 비해 속도가 좋은편에 속하지 못한다.
- 개선방법
  1. 이중 선택 정렬: 한 번의 탐색에서 최솟값과 최댓값을 같이 찾는 방법이다. 탐색 횟수가 절반으로 줄어들게 된다.
  2. 탐색을 응용하여 개선: 한 번의 탐색 때 동일한 값이 있다면 함께 정렬하는 방법이다. 즉, 만약 최솟값을 찾았는데 그 값과 같은 값이 있다면 다음 번 탐색 때 최솟값으로 탐색될 것이기에 이 값도 탐색된 것으로 보고 미리 정렬한다. 같은 값이 많을수록 유용하게 된다.
### 시간복잡도
- O(N²)
  - 비교하는 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 리스트를 이와 같은 방법으로 정렬하는 데에는 Θ(n2) 만큼의 시간이 걸린다.
  - 선택 정렬은 알고리즘이 단순하며 사용할 수 있는 메모리가 제한적인 경우에 사용시 성능 상의 이점이 있다.
  - 시간 복잡도 O(N²)인 정렬 알고리즘 중에서 선택 정렬은 버블 정렬보다 항상 우수하다

### 공간복잡도
- O(N)
  - 주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 O(N)
---
### 참고문헌
- [선택 정렬](https://gyoogle.dev/blog/algorithm/Selection%20Sort.html)
- [선택 정렬](https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC)
- [선택 정렬 장단점](https://jeongkyun-it.tistory.com/62)
- [선택 정렬 장단점](https://coding-factory.tistory.com/615)
