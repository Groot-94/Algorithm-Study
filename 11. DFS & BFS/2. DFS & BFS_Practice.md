- 수꿍
- DFS 구현
```swift
let graph: [String: [String]] = [
    "A" : ["B", "C"],
    "B" : ["A", "D", "E"],
    "C" : ["A", "F"],
    "D" : ["B"],
    "E" : ["B"],
    "F" : ["C"],
]

func DFS(graph: [String: [String]], start: String) -> [String] {
    var visitedQueue: [String] = []
    var needVisitStack: [String] = [start]

    while !needVisitStack.isEmpty {
        let node: String = needVisitStack.removeLast()

        if !visitedQueue.contains(node) {
            visitedQueue.append(node)
            needVisitStack += graph[node] ?? []
        }
    }

    return visitedQueue
}

print(DFS(graph: graph, start: "A"))
```
- DFS 설명
```swift
// 탐색할 그래프 생성
let graph: [String: [String]] = [
    // key 값은 시작 노드
    // value 배열 내 각각의 값은 이동 가능 노드
    "A" : ["B", "C"],
    "B" : ["A", "D", "E"],
    "C" : ["A", "F"],
    "D" : ["B"],
    "E" : ["B"],
    "F" : ["C"],
]

func DFS(graph: [String: [String]], start: String) -> [String] {
    // 이미 탐색한 노드를 담기 위한 큐
    var visitedQueue: [String] = []
    // 해당 노드에 접근하여 다음으로 접근할 노드를 담기 위한 "스택"
    var needVisitStack: [String] = [start]

    // 접근하고자 할 노드가 존재하지 않을때까지 반복
    while !needVisitStack.isEmpty {
        // Stack은 LIFO 방식이기 때문에, 해당 배열에서 removeLast
        let node: String = needVisitStack.removeLast()

        // 이미 방문한 노드가 아닌, 처음 방문한 노드라면
        // visitedQueue에 등록하고
        // 방문해야할 노드를 needVisitStack에 등록
        // 해당 조건문 없을시 무한루프의 위험에 빠짐
        if !visitedQueue.contains(node) {
            visitedQueue.append(node)
            needVisitStack += graph[node] ?? []
        }
    }

    // 깊이 우선 탐색한 큐를 반환
    return visitedQueue
}

// DFS가 정상적으로 작동하였는지 확인
print(DFS(graph: graph, start: "A"))
```
- BFS 구현
```swift
let graph: [String: [String]] = [
    "A" : ["B", "C"],
    "B" : ["A", "D", "E"],
    "C" : ["A", "F"],
    "D" : ["B"],
    "E" : ["B"],
    "F" : ["C"],
]

func BFS(graph: [String: [String]], start: String) -> [String] {
    var visitedQueue: [String] = []
    var needVisitQueue: [String] = [start]

    while !needVisitQueue.isEmpty {
        let node: String = needVisitQueue.removeFirst()

        if !visitedQueue.contains(node) {
            visitedQueue.append(node)
            needVisitQueue += graph[node] ?? []
        }
    }

    return visitedQueue
}

print(BFS(graph: graph, start: "A"))

```
- BFS 설명
```swift
// 탐색할 그래프 생성
let graph: [String: [String]] = [
    // key 값은 시작 노드
    // value 배열 내 각각의 값은 이동 가능 노드
    "A" : ["B", "C"],
    "B" : ["A", "D", "E"],
    "C" : ["A", "F"],
    "D" : ["B"],
    "E" : ["B"],
    "F" : ["C"],
]

func BFS(graph: [String: [String]], start: String) -> [String] {
    // 이미 탐색한 노드를 담기 위한 큐
    var visitedQueue: [String] = []
    // 해당 노드에 접근하여 다음으로 접근할 노드를 담기 위한 "큐"
    var needVisitQueue: [String] = [start]

    // 접근하고자 할 노드가 존재하지 않을때까지 반복
    while !needVisitQueue.isEmpty {
        // Queue는 FIFO 방식이기 때문에, 해당 배열에서 removeFirst
        let node: String = needVisitQueue.removeFirst()

        // 이미 방문한 노드가 아닌, 처음 방문한 노드라면
        // visitedQueue에 등록하고
        // 방문해야할 노드를 needVisitQueue에 등록
        // 해당 조건문 없을시 무한루프의 위험에 빠짐
        if !visitedQueue.contains(node) {
            visitedQueue.append(node)
            needVisitQueue += graph[node] ?? []
        }
    }

    // 너비 우선 탐색한 큐를 반환
    return visitedQueue
}

// BFS가 정상적으로 작동하였는지 확인
print(BFS(graph: graph, start: "A"))

```
