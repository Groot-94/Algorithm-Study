## 01. 거품 정렬(Bubble Sort)
### 요약
- 서로 인접한 두 원소를 비교하여 순서에 맞게 교환하여 정렬하는 알고리즘

### 시각화

<img src="./resources/bubble-sort-001.gif">

### 특징
- 장점
  - 간단한 구현
    - 인접한 값만 계속해서 비교하는 방식
- 단점
  - 비효율(높은 시간복잡도)
    - 배열에서 모든 다른 요소들과 교환 작업이 이루어짐
    - 최종 정렬 위치에 이미 있는 경우라도 교환 발생 가능
    - 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡 -> 버블 정렬은 단순성에도 불구하고 기피

### 시간복잡도
- O(N²)
  - 최선(Ω), 최악(O), 평균(Θ)의 경우 모두 O(n^2)의 시간 복잡도
    - 버블정렬은 외부 루프를 n-1번 도는 동안, n-1, n-2, n-3, ... , 1 번 인접한 원소들을 비교
    - 고로, T(n) = (n - 1) + (n - 2) + (n - 3) + ... + 1 = (n-1) * n / 2 => O(N²)
  - n개 원소에 대해 n개의 메모리를 사용하기에 원소의 개수가 많아지면 비교 횟수가 많아져 성능이 저하

### 공간복잡도
- O(N)
  - 주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 O(N)


---

## 선행지식
### 시간 복잡도
- 알고리즘 평가기준 => 수행 시간 & 메모리 사용량
- 수행 시간 => 시간 복잡도
- 메모리 사용량 => 공간 복잡도

- 연산 횟수를 카운팅 경우의 수
  - 1. 최선의 경우 (Best Case) : O-표기법
  - 2. 평균적인 경우 (Average Case) : Θ-표기법
  - 3. 최악의 경우 (Worst Case) : Ω-표기법

- 최악의 경우로 연산 횟수를 카운트
  - 평균적인 경우를 구하는게 가장 이상적
  - but 알고리즘이 복잡해지고, 다루는 데이터의 크기가 커질수록 평균적인 경우를 계산하기 어려움

- 빅-오 표기법
  - O(1)	
    - 입력 자료의 수에 관계 없이 일정한 실행 시간을 갖는 알고리즘
  - O(logN)	
    - N이 증가함에 따라 실행시간이 조금씩 늘어나는 알고리즘 
    - 문제를 일정한 크기를 갖는 작은 문제로 쪼개어 해결하는 알고리즘
  - O(N)
    - 입력 자료의 수에 따라 선형적으로 실행 시간이 걸리는 알고리즘
  - O(N logN)	
    - 데이터 양이 N배 많아진다면, 실행 시간은 N배보다 조금 더 늘어나는 알고리즘 
    - 문제를 작은 문제로 쪼개어 독립적으로 해결한 다음 그것들을 다시 합치는 알고리즘
  - O(N²)	
    - 이중루프 내에서 데이터를 처리하는 알고리즘 
    - N에따라 수행시간은 제곱이 됨

---
### 참고문헌
- [버블 정렬](https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html)
- [버블 정렬](https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html)
- [버블 정렬](https://roytravel.tistory.com/37)
- [시간복잡도 및 빅오표기법](https://cutewelshcorgi.tistory.com/10)
